[{"content":"Bandit: level 0 → Level 1 登入 1 $ ssh -p 2220 bandit0@bandit.labs.overthewire.org 密碼：bandit0\n題目 關卡目標 下一關的密碼存儲在家目錄（~/）中的一個名為 readme 的檔案裡。使用這個密碼通過 SSH 登入到 bandit1。每當你找到一個關卡的密碼時，使用 SSH（埠 2220）登入到該關卡，然後繼續遊戲。\n你可能需要用到的命令 ls, cd, cat, file, du, find\n解題思路 這題的題目很明瞭的告訴你密碼就在 ~/readme 檔案中。所以問題是要如何開啟這個檔案，獲取裡面儲存的密碼。\n這題需要了解的電腦知識：\n電腦檔案的路徑 ls、cd、cat 指令 詳解 既然都知道是在 readme 檔案裡面了，就只要利用 cat 指令將檔案內容印出即可。\n1 2 3 4 5 6 7 8 bandit0@bandit:~$ cat readme Congratulations on your first steps into the bandit game!! Please make sure you have read the rules at https://overthewire.org/rules/ If you are following a course, workshop, walthrough or other educational activity, please inform the instructor about the rules as well and encourage them to contribute to the OverTheWire community so we can keep these games free! The password you are looking for is: ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If 於是我們就可以輸入\n1 $ exit 或著是按下鍵盤 Ctrl + D，退出連線，然後連接到 bandit1 的帳號\n1 $ ssh -p 2220 bandit1@bandit.labs.overthewire.org 然後輸入剛剛拿到的密碼，進入 Level 1。\nLevel 1 → Level 2\n","date":"2024-05-25T00:46:14+08:00","permalink":"https://blog.yuto0226.com/post/overthewire-bandit-%E8%A7%A3%E9%A1%8C%E7%AD%86%E8%A8%98level-0-level-1/","title":"OverTheWire: Bandit 解題筆記｜Level 0 → Level 1"},{"content":"Bandit: Level 1 → Level 2 登入 1 $ ssh -p 2220 bandit1@bandit.labs.overthewire.org 密碼：ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\n題目 關卡目標 下一關的密碼存儲在主目錄中的一個名為-的文件中。\n你可能需要用到的命令 ls, cd, cat, file, du, find\n有用的閱讀資料\nGoogle 搜索 “dashed filename”（帶破折號的文件名） Advanced Bash-scripting Guide - Chapter 3 - Special Characters 解題思路 詳解 1 2 bandit1@bandit:~$ cat ./- 263JGJPfgU6LtdEvgfWU1XP5yac29mFx OverTheWire: Bandit 解題筆記｜Level 2 → Level 3\n","date":"2024-05-25T00:46:14+08:00","permalink":"https://blog.yuto0226.com/post/overthewire-bandit-%E8%A7%A3%E9%A1%8C%E7%AD%86%E8%A8%98level-1-level-2/","title":"OverTheWire: Bandit 解題筆記｜Level 1 → Level 2"},{"content":"Bandit: Level 0 關卡目標 這一關的目標是讓你使用 SSH 登入遊戲。你需要連接的伺服器是 bandit.labs.overthewire.org，埠 2220。用戶名是 bandit0，密碼是 bandit0。登入後，請前往 第 1 關 頁面，了解如何通過 第 1 關 。\n你可能需要用到的指令\nssh 有用的閱讀資料\nSecure Shell (SSH) on Wikipedia How to use SSH on wikiHow 解題思路 從題目可以知道，要進入遊戲要透過 SSH 登入遠端的主機。所以我們的重點就是去了解要怎麼透過 ssh 指令來進入遠端的主機。\n如果對題目的一些名詞不太熟悉的話這邊列出幾個會要了解的知識：\nWiki: IP 網際網路協定 Wiki: 埠 Wiki: 域名 Wiki: Secure Shell 那簡單來說，我們在使用網路上網的時候。網路上的資源是透過類似現實生活中的信件、包裹的方式傳送資料（網頁、影片\u0026hellip;等等）。\n就如同寄信的時候會需要寄件人以及收件人一樣，電腦也需要被編號成不同的地址，也就是所謂的 IP 地址（IP address）。\n而埠（通訊埠，port），可以想像成一棟大樓的許多樓層及房間。在寄包裹時我們也會標示要給幾號幾樓幾室的某某某。在電腦和電腦之間溝通時，除了必須指定地址外，也必須標示清楚要透過哪一個埠來傳輸資料。\n域名則是幫 IP 地址取一個綽號。人們可以用簡單易懂的名稱來取代原本一坨數字的 IP 地址，例如告訴你 172.217.160.110 這個 IP 地址，會知道這個地址是 Google(google.com) 的 IP 地址嗎？幾乎是不太可能。\nSSH 是一種遠端連線到電腦的協定，可以透過加密方式建立安全的遠端連線。而我們通常會透過 ssh 來連接到其他電腦。\n詳解 首先要先理解如何使用 ssh。這個我就直接問 Chat GPT 了。 :::info 連接到特定通訊埠：\n如果 SSH 伺服器使用非默認通訊埠（22），可以使用 -p 選項指定通訊埠：\n1 ssh -p port_number username@remote_host ::: 這就簡單了，以此類推，要連接上題目要求的伺服器可以這樣下指令：\n1 $ ssh -p 2220 bandit0@bandit.labs.overthewire.org 然後就會跳出一個大大的 BANDIT 要求你輸入密碼，這時把 bandit0 輸入進去就好（輸入沒顯示文字是正常的）。\n那恭喜你成功進入了 level 0 🎉。成功登入之後，會顯示一大堆資訊在螢幕上，大致上在講這個遊戲的資訊、規則，可以斟酌閱讀。\n接著就進入 Level 0 → Level 1 吧。\n","date":"2024-05-24T00:33:14+08:00","permalink":"https://blog.yuto0226.com/post/overthewire-bandit-%E8%A7%A3%E9%A1%8C%E7%AD%86%E8%A8%98level-0/","title":"OverTheWire: Bandit 解題筆記｜Level 0"},{"content":"近日在使用一個 Neovim 的發行版 NVChad，設定 C/C++ 的 LSP Server。然後就遇到了標頭檔找不到的問題。\n可以看到 Neovim 裡面的介面上面出現警告資訊：\n1 \u0026#39;stdio.h\u0026#39; file not found 這就很奇怪了，根據我過往使用 gcc 的經驗，C library 應該是不用再額外引入的。\n找資料 我的第一步就是直接上 Google 找：\n1 nvim clangd 於是我就找到了這一篇 stack overflow 的文章\nWhat standard C library does Clang use? glibc, its own, or some other one? 上面就詢問了 clang 是使用了哪一個 C 的函式庫。\nClang does not come with its own C standard library. Rather, it \u0026ldquo;supports a wide variety of C standard library implementations\u0026rdquo;.\nUnix-like systems including Mac OS ship with their own. Windows does not. On Windows the default arrangement requires Microsoft\u0026rsquo;s Visual C libraries to be installed. It seems that it\u0026rsquo;s also possible to use Clang on Windows with MinGW\u0026rsquo;s libraries though. ╴ hippietrail\n回覆的大略是說，Clang 並沒有自己的 C 函式庫。其中最引人注目的便是他所引入的網址了，妥妥的一手資料，是絕佳的參考資料。\n因此我接著去找 Clangd 的官方文檔，我找到了這段說明\nIf you’re using an unusual compiler (e.g. a cross-compiler for a different platform, or MinGW on Windows) you may want to pass \u0026ndash;query-driver=/path/to/mygcc or \u0026ndash;query-driver=/path/to/mygcc,/path/to/myg++ when using C++ to allow clangd to extract the include paths from it directly.\n這跟我的情況很像，Clang 找不到我的 gcc 帶的 C library。於是我參考了 Configuration 中的指示去把 --query-driver=C:\\Users\\USER\\scoop\\apps\\gcc\\current\\bin 的編譯參數寫入 Clang 的 C:\\Users\\USER\\AppData\\Local\\clangd\\config.yaml，來調整預設的編譯參數。\n1 2 CompileFlags: - --query-driver: C:\\Users\\USER\\scoop\\apps\\gcc\\current\\bin 但很顯然的結果並不那麼美好\n基本上還是一樣的狀況。但隨後我就在 issue 中找到了一篇跟我狀況相似的，同樣是 Windows 作業系統，同樣是用 --query-driver。\nhttps://github.com/clangd/clangd/issues/537#issuecomment-1479544442 總結 上述那篇 issue 的留言給出了一個解法\n1 2 CompileFlags: - --target=x86_64-w64-windows-gnu 參考資料 Clangd:Troubleshooting-Can’t find standard library headers (, \u0026lt;stdio.h\u0026gt; etc) Clangd:Configuration-Files \u0026ndash;query-driver not having any effect #537 ","date":"2024-04-07T01:37:32+08:00","image":"https://blog.yuto0226.com/post/neovim-clangd-no-found-header-file/cover_hu3131304049705876383.png","permalink":"https://blog.yuto0226.com/post/neovim-clangd-no-found-header-file/","title":"Windows 11 中 Neovim clangd 找不到標頭檔"},{"content":"近期悠遊卡公司與Apple進行把悠遊卡加到Apple的支付的事件，在網路上引發熱烈討論。然而，悠遊卡的資安問題也再度受到關注。\n悠遊卡的運作原理 悠遊卡系統主要是應用 法拉第電磁感應定律 來傳遞資訊。卡片內部有埋設線圈，當卡片靠近讀卡機時，讀卡機所產生的電場會讓線圈產生電流，供應給裡面的晶片（IC）產生電磁波訊號，再由讀卡機接收並解析資料。\n這個技術被稱為「無線射頻辨識系統」（radio frequency identification，RFID），而悠遊卡裡面的則是RFID規格則是採用NXP公司的MIFARE Classic。\nMIFARE的安全性 MIFARE是恩智浦半導體公司（NXP Semiconductors）擁有的一系列RFID技術。其成本低廉，讓他在目前市面上廣泛應用於各種系統，ex：門禁系統、圖書館借書證、識別卡\u0026hellip;等等。\n然而，MIFARE 的安全性備受質疑。早在 2007 年，就有駭客破解了 MIFARE 晶片的演算法，並且有相關論文探討。\n2007年12月，在騷亂交流大會上Henryk Plötz和Karsten Nohl[6]發表了部分用於MIFARE晶片演算法上的逆向工程技術[7]。 維基百科：MIFARE\n而台灣的紀錄著名的則有：\n2010年7月，臺灣大學電機系教授鄭振牟團隊使用改進過的監聽封包（Sniffer-Based）的攻擊手法攻擊Mifare卡。將1張正常使用中的悠遊卡，將餘額從正100多元，更改成為負五百多元[12]。 維基百科：MIFARE\n在2021 SITCON 學生計算機年會，也有講者於「RFID 硬體資安實戰」議程中分享MIFARE卡的資安問題。由此也可以看出其安全問題早已存在很久了。\n悠遊卡公司的應對方式 遊遊卡公司面對這樣的資安問題，也只有透過補漏動的方式監督使用者。主要的作法為：\n用法律方式來嚇阻 搭配後台的資料庫核對不正當的竄改資料。 改善方法 相較於於悠遊卡的MIFARE Classic技術，日本SUICA所使用的Felica技術具有更高的安全性，Apple也早已將SUICA整合進Apple Pay中。\n此外，Apple也早已接納同是MIFARE家族，但安全性更高的MIFARE DESFire規格。\n參考資料 一卡在手便利無窮，悠遊卡的設計原理——《我們的生活比你想的還物理》 悠遊卡遭駭，Mifare卡安全性遭質疑 FeliCa、Mifareの違いを解説！ICカードの種類と特長を比較する Apple Pay為什麼不支援悠遊卡原因完全揭秘，金管會給出獨家答案 Apple\u0026rsquo;s Core NFC Framework 維基百科：悠遊卡 維基百科：MIFARE ","date":"2024-02-26T00:00:00Z","image":"https://blog.yuto0226.com/post/%E6%82%A0%E9%81%8A%E5%8D%A1%E7%9A%84%E8%B3%87%E5%AE%89%E5%95%8F%E9%A1%8C/cover_hu517696041661522043.png","permalink":"https://blog.yuto0226.com/post/%E6%82%A0%E9%81%8A%E5%8D%A1%E7%9A%84%E8%B3%87%E5%AE%89%E5%95%8F%E9%A1%8C/","title":"悠遊卡的資安問題"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 import cv2 as cv cam = cv.VideoCapture(0) while True: ret, frame = cam.read() cv.imshow(\u0026#39;cam\u0026#39;,frame) if cv.waitKey(1)==ord(\u0026#39;q\u0026#39;): break cam.release() cv.destroyAllWindows() ","date":"2023-08-06T14:51:43Z","permalink":"https://blog.yuto0226.com/post/opencv-%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BD%AE%E6%94%9D%E5%BD%B1%E6%A9%9F/","title":"OpenCV 使用前置攝影機"},{"content":"到 控制台/使用者帳戶/認證管理員/Windows 認證 刪除GitHub的認證之後再重登即可\n","date":"2023-02-17T14:21:43Z","permalink":"https://blog.yuto0226.com/post/git%E5%88%87%E6%8F%9B%E5%B8%B3%E8%99%9F/","title":"Git切換帳號"},{"content":"基本型 ▲２六歩 △８四歩 ▲２五歩 △８五歩 ▲７八金 △３二金 ▲２四歩 △同　歩 ▲同　飛 △２三歩\n{%img https://shogipic.jp/v/ax@3x.png 360 270%}\n","date":"2023-01-11T17:21:34Z","image":"https://shogipic.jp/v/ax@3x.png","permalink":"https://blog.yuto0226.com/post/%E7%9B%B8%E6%8E%9B%E3%81%8B%E3%82%8A%E5%9F%BA%E6%9C%AC%E5%9E%8B/","title":"相掛かり(基本型)"},{"content":"stdlib.h rand() 1 int rand(void); 產生介於0~RAND_MAX(=32767)之間的隨機亂數，需要透過srand()來初始化\nsrand() 1 void srand(unsigned int seed); 透過傳進來的seed初始化rand()，seed若不改變則每次所產生的亂數皆會相同。\ntime.h time() 1 time_t time(time_t* timer); time(NULL)會回傳自1970年午夜到現在所經過的秒數，可以用作srand的seed，每次執行的seed皆會不一樣\nrand() scaled and shifted 1 int scale_rand(int start,int end) return start+rand()%end; ","date":"2022-11-21T23:09:10Z","permalink":"https://blog.yuto0226.com/post/c%E8%AA%9E%E8%A8%80rand%E5%87%BD%E5%BC%8F%E7%9A%84%E7%94%A8%E6%B3%95/","title":"C語言rand()函式的用法"},{"content":"用 CTAN 單獨把遺失的檔案載回來，整個資料夾放回 C:\\texlive\\\u0026lt;年分\u0026gt;\\texmf-dist\\tex\\latex，然後在 Terminal 裡面 :\n1 texhash ","date":"2022-11-21T01:04:43Z","permalink":"https://blog.yuto0226.com/post/latex-%E7%B7%A8%E8%AD%AF%E6%99%82%E7%BC%BA%E5%B0%91-.sty-%E6%AA%94%E6%A1%88/","title":"Latex 編譯時缺少 .sty 檔案"},{"content":"0.2.1 基本C++模板與輸入輸出 1 2 3 4 5 6 7 8 #include \u0026lt;bits/stdc++.h\u0026gt; // 萬用標頭檔 using namespace std; int main(){ ios::sync_with_stdio(0); // 優化cin的東西 cin.tie(0); // code here return 0; } 有優化cin的那兩行就不能再把cin/cout與scanf/printf混用，不然會發生無法預測的錯誤\n使用scanf/printf 使用cin/cout並優化 0.2.2 程式測試與測試資料 stdin: 標準輸入裝置，預設鍵盤 stdout: 標準輸出裝置，預設螢幕 stderr: 標準錯誤紀錄裝置，預設螢幕 unix環境下的IO重導:\n1 ./a.out \u0026lt;test.in \u0026gt;test.out 程式裡面I/O重導:\n1 2 freopen(\u0026#34;test.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;test.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); unix環境下計時:\n1 time a.out \u0026lt;test.in 程式裡面計時:\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ clock_t start,end; start=clock(); // code here end=clock(); fprint(stderr,\u0026#34;time from start to end = %f sec.\\n\u0026#34;,(float)(end-start)/CLOCKS_PER_SEC); return 0; } 0.2.3 複雜度估算 複雜度估算方式 時間複雜度通常以$O(f(n))$來表示，念作big-O，以n來表示資料量，常數倍通常忽略不計 常見的有:$O(n)$、$O(nlog(n))$、$(n^2)$\n由資料量大小推估所需複雜度 題目會說明資料量的大小跟時間限制(time limit)，可以用這兩點去推估時間複雜度 可以一秒$10^6$~$10^7$的指令數量來估計\nn 超過1萬 數千 數百 20~25 10 複雜度 $O(n)$ or $O(nlog(n))$ $O(n^2)$ $O(n^3)$ $O(2^n)$ $O(n!)$ 複雜度需要留意的幾件事 sort/qsort可以視為$O(nlog(n))$ Big-O通常指的是上限，而未必是緊實的上限(tight bound) $O(n^x)$ 在x是常數時成立 0.2.4 需要留意的是 ","date":"2022-11-18T20:57:16Z","permalink":"https://blog.yuto0226.com/post/0.%E6%95%99%E6%9D%90%E8%AA%AA%E6%98%8E%E8%88%87%E9%A0%90%E5%82%99%E7%9F%A5%E8%AD%98/","title":"0.教材說明與預備知識"},{"content":"程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Node{ public: int start; int end; int max; int min; int sum; Node *left=nullptr; Node *right=nullptr; Node(int start,int end,int max,int min,int sum,Node *left=nullptr,Node *right=nullptr): start(start),end(end),max(max),min(min),sum(sum),left(left),right(right){} }; Node *build(int start,int end,int val[]){ if(start==end){ //cout\u0026lt;\u0026lt;\u0026#34;build: [\u0026#34;\u0026lt;\u0026lt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;\u0026#34;] node-\u0026gt;,max,min,sum=\u0026#34;\u0026lt;\u0026lt;val[start]\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return new Node(start,end,val[start],val[start],val[start],nullptr,nullptr); } int mid=(start+end)/2; Node *left=build(start,mid,val); Node *right=build(mid+1,end,val); //cout\u0026lt;\u0026lt;\u0026#34;build: [\u0026#34;\u0026lt;\u0026lt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;\u0026#34; node-\u0026gt;max=\u0026#34;\u0026lt;\u0026lt;max(left-\u0026gt;max,right-\u0026gt;max)\u0026lt;\u0026lt;\u0026#34; node-\u0026gt;min=\u0026#34;\u0026lt;\u0026lt;min(left-\u0026gt;min,right-\u0026gt;min)\u0026lt;\u0026lt;\u0026#34; node-\u0026gt;sum=\u0026#34;\u0026lt;\u0026lt;left-\u0026gt;sum+right-\u0026gt;sum\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return new Node(start,end,max(left-\u0026gt;max,right-\u0026gt;max),min(left-\u0026gt;min,right-\u0026gt;min),left-\u0026gt;sum+right-\u0026gt;sum,left,right); } int query_sum(Node *root,int i,int j){ int sum=0; //cout\u0026lt;\u0026lt;\u0026#34;query: [\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;] @ [\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;root-\u0026gt;end\u0026lt;\u0026lt;\u0026#34;] root-\u0026gt;sum=\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;sum\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(root-\u0026gt;start==root-\u0026gt;end) return root-\u0026gt;sum; if(root-\u0026gt;start==i\u0026amp;\u0026amp;root-\u0026gt;end==j) return root-\u0026gt;sum; int mid=root-\u0026gt;start+(root-\u0026gt;end-root-\u0026gt;start)/2; if(j\u0026lt;=mid) return query_sum(root-\u0026gt;left,i,j); else if(i\u0026gt;mid) return query_sum(root-\u0026gt;right,i,j); else return query_sum(root-\u0026gt;left,i,mid)+query_sum(root-\u0026gt;right,mid+1,j); } int query_max(Node *root,int i,int j){ int sum=0; //cout\u0026lt;\u0026lt;\u0026#34;query: [\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;] @ [\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;root-\u0026gt;end\u0026lt;\u0026lt;\u0026#34;] root-\u0026gt;max=\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;max\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(root-\u0026gt;start==root-\u0026gt;end) return root-\u0026gt;max; if(root-\u0026gt;start==i\u0026amp;\u0026amp;root-\u0026gt;end==j) return root-\u0026gt;max; int mid=root-\u0026gt;start+(root-\u0026gt;end-root-\u0026gt;start)/2; if(j\u0026lt;=mid) return query_max(root-\u0026gt;left,i,j); else if(i\u0026gt;mid) return query_max(root-\u0026gt;right,i,j); else return max(query_max(root-\u0026gt;left,i,mid),query_max(root-\u0026gt;right,mid+1,j)); } int query_min(Node *root,int i,int j){ int sum=0; //cout\u0026lt;\u0026lt;\u0026#34;query: [\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;] @ [\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;root-\u0026gt;end\u0026lt;\u0026lt;\u0026#34;] root-\u0026gt;min=\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;min\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(root-\u0026gt;start==root-\u0026gt;end) return root-\u0026gt;min; if(root-\u0026gt;start==i\u0026amp;\u0026amp;root-\u0026gt;end==j) return root-\u0026gt;min; int mid=root-\u0026gt;start+(root-\u0026gt;end-root-\u0026gt;start)/2; if(j\u0026lt;=mid) return query_min(root-\u0026gt;left,i,j); else if(i\u0026gt;mid) return query_min(root-\u0026gt;right,i,j); else return min(query_min(root-\u0026gt;left,i,mid),query_min(root-\u0026gt;right,mid+1,j)); } ","date":"2022-11-13T20:21:16Z","permalink":"https://blog.yuto0226.com/post/segment-tree/","title":"[C++]線段樹"},{"content":"TLE解 用multimap的索引會排序的特性把n跟cycle(n)反著存進map裡面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //ZeroJudge d713 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int cycle(int n,int len){ //printf(\u0026#34;%d \u0026#34;,n); if(n==1) return len+1; if(n%2!=0) len=cycle(3*n+1,len+1); else len=cycle(n/2,len+1); return len; } int main(){ multimap\u0026lt;int,int\u0026gt; mmap; for(int i=1;i\u0026lt;100000;i++) mmap.insert(make_pair(cycle(i,0),i)); int a,b; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b)!=EOF){ //cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; \u0026#34;; printf(\u0026#34;%d %d \u0026#34;,a,b); if(a\u0026lt;b) swap(a,b); for(auto it=--mmap.end();it!=mmap.begin();it--){ if((*it).second\u0026lt;a \u0026amp;\u0026amp; (*it).second\u0026gt;b){ //cout\u0026lt;\u0026lt;(*it).first\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; printf(\u0026#34;%d\\n\u0026#34;,(*it).first); break; } } } return 0; } 線段樹解 目前測資2沒過\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //ZeroJudge d713 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int cycle(int n,int len){ //printf(\u0026#34;%d \u0026#34;,n); if(n==1) return len+1; if(n%2!=0) len=cycle(3*n+1,len+1); else len=cycle(n/2,len+1); return len; } class Node{ public: int start; int end; int max; Node *left=nullptr; Node *right=nullptr; Node(int start,int end,int max,Node *left=nullptr,Node *right=nullptr): start(start),end(end),max(max),left(left),right(right){} }; Node *build(int start,int end,int val[]){ if(start==end){ //if(end\u0026lt;=300) cout\u0026lt;\u0026lt;\u0026#34;build: [\u0026#34;\u0026lt;\u0026lt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;\u0026#34;] node-\u0026gt;max=\u0026#34;\u0026lt;\u0026lt;val[start]\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return new Node(start,end,val[start],nullptr,nullptr); } int mid=(start+end)/2; Node *left=build(start,mid,val); Node *right=build(mid+1,end,val); //if(end\u0026lt;=300) cout\u0026lt;\u0026lt;\u0026#34;build: [\u0026#34;\u0026lt;\u0026lt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;\u0026#34; node-\u0026gt;max=\u0026#34;\u0026lt;\u0026lt;max(left-\u0026gt;max,right-\u0026gt;max)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return new Node(start,end,max(left-\u0026gt;max,right-\u0026gt;max),left,right); } int query_max(Node *root,int i,int j){ int sum=0; if(root-\u0026gt;start==root-\u0026gt;end) return root-\u0026gt;max; if(root-\u0026gt;start==i\u0026amp;\u0026amp;root-\u0026gt;end==j) return root-\u0026gt;max; int mid=root-\u0026gt;start+(root-\u0026gt;end-root-\u0026gt;start)/2; //cout\u0026lt;\u0026lt;\u0026#34;query: [\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;] @ [\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;start\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;root-\u0026gt;end\u0026lt;\u0026lt;\u0026#34;] root-\u0026gt;max=\u0026#34;\u0026lt;\u0026lt;root-\u0026gt;max\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(j\u0026lt;=mid) return query_max(root-\u0026gt;left,i,j); else if(i\u0026gt;mid) return query_max(root-\u0026gt;right,i,j); else return max(query_max(root-\u0026gt;left,i,mid),query_max(root-\u0026gt;right,mid+1,j)); } int arr[1000002]; int main(){ for(int i=1;i\u0026lt;100000;i++) arr[i]=cycle(i,0); Node *root=build(0,1000000,arr); int a,b; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b)!=EOF){ printf(\u0026#34;%d %d \u0026#34;,a,b); if(a\u0026gt;b) swap(a,b); printf(\u0026#34;%d\\n\u0026#34;,query_max(root,a,b)); } return 0; } ","date":"2022-11-13T22:50:34+08:00","permalink":"https://blog.yuto0226.com/post/zj_d712/","title":"d712. The 3n + 1 problem"},{"content":"最近在看 beneater 的 8-bit cpu 想說用 C++ 寫看看練練手，所以就寫出來啦~ 由於還沒對 CPU 理解得很徹底，只有把ALU做出來而已，以後再看看會不會在重寫一個哈哈。\n架構 accumulator register b register instruction register program counter 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #include\u0026lt;bits/stdc++.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; using byte=uint8_t; byte accumulator; // accumulator register byte b; // register b byte instruction; // instruction register byte counter; // program counter bool negitive; // negitive flag bool sign; // sign flag bool HLT=0; byte memory[256]={0b11110000}; bool isDebug=0; void reset(){ accumulator=0; b=0; counter=0; instruction=0; for(int i=0;i\u0026lt;256;i++) memory[i]=0b11110000; } void fetch(){ if(HLT) return; instruction=memory[counter]; counter+=1; } void STA(){ if(isDebug) printf(\u0026#34;%#4x STA: %#x\\n\u0026#34;,counter,memory[counter]); accumulator=memory[counter]; counter+=1; } void STB(){ if(isDebug) printf(\u0026#34;%#4x STB: %#x\\n\u0026#34;,counter,memory[counter]); b=memory[counter]; counter+=1; } void ADD(){ if(isDebug) printf(\u0026#34;%#4x ADD: %#x\\n\u0026#34;,counter,memory[counter]); b=memory[counter]; accumulator+=b; counter+=1; } void OUT(){ if(isDebug) printf(\u0026#34;%#4x OUT\\n\u0026#34;,counter); printf(\u0026#34;%#4x\\n\u0026#34;,accumulator); } void decode(){ instruction/=16; if(isDebug) printf(\u0026#34;%#4x instruction: %#x\\n\u0026#34;,counter-1,instruction); switch(instruction){ case 0x0001: // STA STA(); break; case 0b0010: // LDA break; case 0b0011: // STB STB(); break; case 0b0100: // LDB break; case 0b0101: // ADD ADD(); break; case 0b1101: // OUT OUT(); break; case 0b1110: // HLT if(isDebug) printf(\u0026#34;%#4x HLT\\n\u0026#34;,counter); HLT=1; break; case 0b1111: // NOP if(isDebug) printf(\u0026#34;%#4x NOP\\n\u0026#34;,counter); break; } } void print_register(byte reg){ for(int i=0;i\u0026lt;8;i++){ printf(\u0026#34;%u\u0026#34;,reg/128); reg*=2; } } void print_memory(byte address){ for(int i=0;i\u0026lt;8;i++){ printf(\u0026#34;%u\u0026#34;,memory[address]/128); memory[address]*=2; } } void debug(){ if(!isDebug) return; printf(\u0026#34;\\n%4#x \u0026#34;,counter); printf(\u0026#34;%4#x\\n\u0026#34;,memory[counter]); printf(\u0026#34;register:\\n\u0026#34;); printf(\u0026#34;%14s %4#x\\n\u0026#34;,\u0026#34;accumulator\u0026#34;,accumulator); printf(\u0026#34;%14s %4#x\\n\u0026#34;,\u0026#34;b\u0026#34;,b); printf(\u0026#34;%14s %4#x\\n\u0026#34;,\u0026#34;instruction\u0026#34;,instruction); } int main(){ reset(); memory[0]=0b00010000; // LDA memory[1]=0b00000001; memory[2]=0b01010000; // ADD memory[3]=0b00000001; memory[4]=0b11010000; // HLT memory[5]=0b11100000; while(!HLT){ // fetch //debug(); fetch(); decode(); } return 0; } ","date":"2022-11-05T23:13:30Z","permalink":"https://blog.yuto0226.com/post/%E7%94%A8-c-%E6%A8%A1%E6%93%AC%E7%B0%A1%E5%96%AE%E7%9A%84-8-bit-cpu/","title":"用 C++ 模擬簡單的 8-bit cpu"},{"content":"題目 有一個公司有$n$個員工，還有兩個工廠。如果工廠一與工廠二分別有$X_1$與$X_2$個員工，兩個工廠的收益$Y_1$,$Y_2$分別會是 $$ Y_1=A_1X_1^2+B_1X_1+C_1\\ Y_2=A_2X_2^2+B_2X_2+C_2 $$ 請你考慮所有分配員工的方式，找出收益最大的組合，輸出最大收益。 注意，每個員工皆需分配到其中一個工廠。\n輸入格式 第一行有三個整數$A_1,B_1,C_1$ 第二行有三個整數$A_2,B_2,C_2$ 第三行有一個正整數($1\u0026lt;=n\u0026lt;=100$)\n輸出格式 輸出最大收益\n解題方向 暴力破解法。x1跟x2的關係會是x2=n-x1，用for迴圈把x1或x2從1代到n找最大值。\n參考程式碼 [AC]{.green} (4ms, 336KB)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //ZeroJudge f312 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){\tint A1,B1,C1,A2,B2,C2,n,ans=-2147483648; cin\u0026gt;\u0026gt;A1\u0026gt;\u0026gt;B1\u0026gt;\u0026gt;C1; cin\u0026gt;\u0026gt;A2\u0026gt;\u0026gt;B2\u0026gt;\u0026gt;C2; cin\u0026gt;\u0026gt;n; for(int x1=0;x1\u0026lt;=n;x1++){ int x2=n-x1; int y1=A1*x1*x1+B1*x1+C1; int y2=A2*x2*x2+B2*x2+C2; ans=max(ans,y1+y2); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":"2022-10-15T11:47:18Z","permalink":"https://blog.yuto0226.com/post/zj_f312/","title":"f312. 1.人力分配"},{"content":"之前曾經嘗試在Windows上學寫組合語言，得到的回饋只有滿滿的問號。編譯過程出現了很多跟在Linux上不同的例外，這更證明了學習程式語言不難，難的是設定開發環境。 山不轉路轉路不轉人轉，我們直接用WSL上的環境去開發，就可以直接省去很多只會阻饒你學習的問題。而關於Windows Terminal和WSL的安裝可以參考Before the Course\n編譯工具 回歸正題，編譯組合語言會需要兩個程式: nasm、ld。nasm是用來把.asm檔轉成.o檔，而ld則是再把.o轉成可以執行的檔案。\n更新 apt 安裝套件前要把apt更新上去，不然有機會會找不到東西安裝冏事發生(本人我還真的卡了一下)\n1 2 sudo apt-get update sudo apt upgrade nasm 其實安裝NASM很簡單，直接用Ubuntu內建的套件管理包安裝就行了。\n1 sudo apt install nasm ld ld的話在GCC裡面有內建，所以如果要裝的話要裝GCC，也就是編譯C/C++的工具。\n1 sudo apt install nasm ","date":"2022-10-10T22:09:59Z","permalink":"https://blog.yuto0226.com/post/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A/","title":"組合語言開發環境設定"},{"content":"射法八節是日本弓道中基本的規則，對其熟悉是非常重要的\n{足踏み^あしぶ} {胴造り^どうづく} {弓構え^ゆがま} {打起し^うちおこ} {引分け^ひきわ} {会^かい} {離れ^はな} {残心^ざんしん} ","date":"2022-09-28T19:04:33Z","permalink":"https://blog.yuto0226.com/post/%E5%B0%84%E6%B3%95%E5%85%AB%E7%AF%80/","title":"射法八節"},{"content":"射法八節是日本弓道中基本的規則，對其熟悉是非常重要的\n{足踏み^あしぶ} {胴造り^どうづく} {弓構え^ゆがま} {打起し^うちおこ} {引分け^ひきわ} {会^かい} {離れ^はな} {残心^ざんしん} ","date":"2022-09-28T19:04:33Z","permalink":"https://blog.yuto0226.com/post/%E5%B0%84%E6%B3%95%E5%85%AB%E7%AF%80/","title":"射法八節"},{"content":"MIT的教授們所開設的課程。每堂課都有線上筆記可以參考。\nThe Shell 當你打開Shell，統常只會有一行字在做上方，稱作系統提示(Shell Prompt)。\n1 [root@localhost] $ 上面有使用者名稱(user name)跟現在使用的機器名稱還有現在所在的路徑(path)。你可以在系統提示輸入指令Shell會解析指令，例如最簡單的指令便是執行一個程式且帶有引數(argument):\n1 2 date Tue Sep 27 08:40:51 CST 2022 以date這隻程式來說，他會把現在的日期跟時間印在shell上。 那當然也可以使用帶有引數的程式:\n1 2 echo hello hello ","date":"2022-09-26T17:30:41Z","permalink":"https://blog.yuto0226.com/post/lecture-1course-overview--the-shell/","title":"Lecture 1:Course Overview + The Shell"},{"content":"課程裡面所使用的環境都是類UNIX系統。如果你是Windows系統的話就要用WSL來模擬LINUX的環境，而且可能會有很多東西跟教授所講的不太一樣。接下來會用Windows 11操作。\n:::warning Windows 10 版本必須是 2004 (19041.450) 以上 :::\nWindows Terminal 一個可以讓你Terminal漂漂亮亮的東西 Microsoft Store的連結\nWindows 功能 直接去搜尋打上Windows 功能並點開 把裡面的Windows 子系統 Linux 版跟虛擬機平台勾起來 開啟WindowsTerminal(Power Shell或命令提示字元都可以)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 wsl --install 著作權 (c) Microsoft Corporation。保留擁有權利。 使用方式: wsl.exe [Argument] [Options...] [CommandLine] 用於執行 Linux 二進位檔的引數: 如果未提供任何命令列，wsl.exe 會啟動預設的殼層。 --exec, -e \u0026lt;CommandLine\u0026gt; 執行指定的命令，但不使用預設的 Linux 殼層。 -- 依原樣傳遞剩餘的命令列。 選項: --cd \u0026lt;Directory\u0026gt; 將指定的目錄設定為目前的工作目錄。 如果使用 ~，將會使用 Linux 使用者的主目錄路徑。如果該路徑的開頭 為 / 字元，將會解譯為絕對 Linux 路徑。 否則，該值必須是絕對 Windows 路徑。 --distribution, -d \u0026lt;Distro\u0026gt; 執行指定的發佈。 --user, -u \u0026lt;UserName\u0026gt; 以指定使用者的身分執行。 --system 啟動系統發佈的殼層。 用於管理 Windows 子系統 Linux 版的引數: --help 顯示使用資訊。 --install [Options] 安裝其他 Windows 子系統 Linux 版發佈。 如需有效發佈的清單，請使用 \u0026#39;wsl --list --online\u0026#39;。 選項: --distribution, -d [Argument] 依名稱下載並安裝發佈。 引數: 有效發佈名稱 (不區分大小寫)。 範例: wsl --install -d Ubuntu wsl --install --distribution Debian --set-default-version \u0026lt;Version\u0026gt; 針對新發佈變更預設安裝版本。 --shutdown 立即終止所有執行中的發佈和 WSL 2 輕量公用程式虛擬機器。 --status 顯示 Windows 子系統 Linux 版狀態。 --update [Options] 如果未指定選項，則會更新 WSL 2 核心 至最新版本。 選項: --rollback 還原至舊版 WSL 2 核心。 在 Windows 子系統 Linux 版中用於管理發佈的引數: --export \u0026lt;Distro\u0026gt; \u0026lt;FileName\u0026gt; 將發佈匯出為 tar 檔案。 檔案名稱可以是 - 以用於標準輸出。 --import \u0026lt;Distro\u0026gt; \u0026lt;InstallLocation\u0026gt; \u0026lt;FileName\u0026gt; [Options] 匯入指定的 tar 檔案作為新發佈。 檔案名稱可以是 - 以用於標準輸入。 選項: --version \u0026lt;Version\u0026gt; 指定要用於新發佈的版本。 --list, -l [Options] 列出發佈。 選項: --all 列出全部發佈，包含 正在安裝或解除安裝的發佈。 --running 只列出目前正在執行的發佈。 --quiet, -q 只顯示發佈名稱。 --verbose, -v 顯示所有發佈的詳細資訊。 --online, -o 顯示可用發佈的清單，以使用 \u0026#39;wsl --install\u0026#39; 安裝。 --set-default, -s \u0026lt;Distro\u0026gt; 將發佈設定為預設值。 --set-version \u0026lt;Distro\u0026gt; \u0026lt;Version\u0026gt; 變更所指定發佈的版本。 --terminate, -t \u0026lt;Distro\u0026gt; 終止指定的發佈。 --unregister \u0026lt;Distro\u0026gt; 取消登錄發佈並刪除根檔案系統。 --mount \u0026lt;Disk\u0026gt; 在所有 WSL2 發佈中連結並裝載實體磁碟。 選項: --bare 將磁碟連結到 WSL2，但不要裝載磁碟。 --type \u0026lt;Type\u0026gt; 裝載磁碟時要使用的檔案系統，若未指定，預設為 ext4。 --options \u0026lt;Options\u0026gt; 其他裝載選項。 --partition \u0026lt;Index\u0026gt; 要裝載之磁碟分割的索引，若未指定，預設為整個磁碟。 --unmount [Disk] 從所有 WSL2 發佈卸載並中斷連結磁碟。 若在沒有引數的情況下呼叫，即卸載並中斷連結所有磁碟。 可以用參數-l -o把所有發行版都印出來\n1 2 3 4 5 6 7 8 9 10 11 12 13 wsl -l -o 以下是可安裝之有效發佈的清單。 使用 \u0026#39;wsl --install -d \u0026lt;Distro\u0026gt;\u0026#39; 安裝。 NAME FRIENDLY NAME Ubuntu Ubuntu Debian Debian GNU/Linux kali-linux Kali Linux Rolling openSUSE-42 openSUSE Leap 42 SLES-12 SUSE Linux Enterprise Server v12 Ubuntu-16.04 Ubuntu 16.04 LTS Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS 挑自己喜歡的版本按照上面給的提示安裝，以Ubuntu為例:\n1 wsl --install -d Ubuntu ","date":"2022-09-26T17:29:58Z","permalink":"https://blog.yuto0226.com/post/before-the-course/","title":"Before the Course"},{"content":"感知機 PLA 針對線性資料的分類 訓練後 函式\u0026amp;變數 dot()，將兩向量(double)內積並回傳其值(double)。 1 double dot(std::vector\u0026lt;double\u0026gt; vec_1, std::vector\u0026lt;double\u0026gt; vec_2); vec_to_str()，將向量轉換成 string 並回傳。 1 std::string vec_to_str(std::vector\u0026lt;double\u0026gt; vec); intput_data()，輸入一組資料(輸入向量\u0026amp;類型) 1 train_data intput_data(int dimension); class train_data 1 2 3 4 5 6 7 8 9 10 11 class train_data{ private: std::vector\u0026lt;double\u0026gt; inputs; bool is_type; public: train_data(std::vector\u0026lt;double\u0026gt; inputs, bool is_type); std::vector\u0026lt;double\u0026gt; get_intputs(); bool get_type(); std::string to_str(); }; private 輸入層向量。 1 std::vector\u0026lt;double\u0026gt; inputs; 類型。 1 bool is_type; public 建構元，直接初始化輸入向量和類型。 1 train_data(std::vector\u0026lt;double\u0026gt; inputs, bool is_type); get_intputs()，回傳輸入層向量。 1 std::vector\u0026lt;double\u0026gt; get_intputs(); get_type()，回傳類型。 1 bool get_type(); to_str()，將 train_data 物件的輸入向量、類型轉換成字串回傳。 1 std::string to_str(); class perceptron 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class perceptron{ private: std::vector\u0026lt;train_data\u0026gt; data; std::vector\u0026lt;double\u0026gt; weights; double bias; double learning_rate; void init_weights(); void init_bias(); double cost(train_data data); void update(train_data data); void train_epoch(); public: perceptron(std::vector\u0026lt;train_data\u0026gt; data, double learning_rate); bool predict_type(train_data data); void train(int epochs,bool reset); std::string to_str(); }; private data，訓練資料陣列。 1 std::vector\u0026lt;train_data\u0026gt; data; weights，權重向量。 1 std::vector\u0026lt;double\u0026gt; weights; bias，偏置值(閥值)。 1 double bias; learning_rate，學習率。 1 double learning_rate; init_weights()，初始化權重向量。 1 void init_weights(); init_bias，初始化偏置值。 1 void init_bias(); cost()，回傳 cost 1 double cost(train_data data); update()，更新權重。 1 void update(train_data data); train_epoch()，訓練完一組資料。 1 void train_epoch(); public 建構元，設定輸入向量陣列、學習率。 1 perceptron(std::vector\u0026lt;train_data\u0026gt; data, double learning_rate); predict_type()，感知姬預測的類型 1 bool predict_type(train_data data); train()，訓練感知機。 1 void train(int epochs,bool reset); to_str()，把權重、偏置值及學習率轉換成字串後回傳。 1 std::string to_str(); 預設資料集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int main(){ std::vector\u0026lt;train_data\u0026gt; data; int n_data=20; int n_dimension=0; double learning_rate=0; double n_correct=0; int n_epoch=0; clock_t start,end; for(size_t i=0;i\u0026lt;n_data;i++){ data.push_back(_data(i)); } std::cout\u0026lt;\u0026lt;\u0026#34;data: \\n\u0026#34;; for(int i=0;i\u0026lt;data.size();i++){ std::cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;] \u0026#34;\u0026lt;\u0026lt;data[i].to_str()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } std::cout\u0026lt;\u0026lt;\u0026#34;learning rate: \u0026#34;; std::cin\u0026gt;\u0026gt;learning_rate; std::cout\u0026lt;\u0026lt;\u0026#34;epoch: \u0026#34;; std::cin\u0026gt;\u0026gt;n_epoch; perceptron PLA(data, learning_rate); start = clock(); PLA.train(n_epoch,false); end = clock(); for(size_t i=0;i\u0026lt;n_data;i++){ std::cout\u0026lt;\u0026lt;\u0026#34;data[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]: predict -\u0026gt; \u0026#34;\u0026lt;\u0026lt; PLA.predict_type(data[i])\u0026lt;\u0026lt;\u0026#34;, actual -\u0026gt; \u0026#34;\u0026lt;\u0026lt;data[i].to_str(); if(PLA.predict_type(data[i])==data[i].get_type()){ std::cout\u0026lt;\u0026lt;GREEN\u0026lt;\u0026lt;\u0026#34; ✓ \\n\u0026#34;\u0026lt;\u0026lt;RESET; n_correct+=1; }else{ std::cout\u0026lt;\u0026lt;RED\u0026lt;\u0026lt;\u0026#34; x \\n\u0026#34;\u0026lt;\u0026lt;RESET; } } std::cout\u0026lt;\u0026lt;PLA.to_str()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; std::cout\u0026lt;\u0026lt;\u0026#34;correct rate: \u0026#34;\u0026lt;\u0026lt;(n_correct/n_data)*100\u0026lt;\u0026lt;\u0026#34;%, time: \u0026#34;\u0026lt;\u0026lt;((double)end-start)/CLK_TCK; return 0; } 手動輸入資料集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int main(){ std::vector\u0026lt;train_data\u0026gt; data; int n_data=20; double learning_rate=0; double n_correct=0; int n_epoch=0; clock_t start,end; std::cout\u0026lt;\u0026lt;\u0026#34;dimension: \u0026#34;; std::cin\u0026gt;\u0026gt;n_dimension; std::cout\u0026lt;\u0026lt;\u0026#34;data amount: \u0026#34;; std::cin\u0026gt;\u0026gt;n_data; for(size_t i=0;i\u0026lt;n_data;i++){ data.push_back(intput_data(n_dimension)); } std::cout\u0026lt;\u0026lt;\u0026#34;learning rate: \u0026#34;; std::cin\u0026gt;\u0026gt;learning_rate; std::cout\u0026lt;\u0026lt;\u0026#34;epoch: \u0026#34;; std::cin\u0026gt;\u0026gt;n_epoch; perceptron PLA(data, learning_rate); start = clock(); PLA.train(n_epoch,false); end = clock(); for(size_t i=0;i\u0026lt;n_data;i++){ std::cout\u0026lt;\u0026lt;\u0026#34;data[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]: predict -\u0026gt; \u0026#34;\u0026lt;\u0026lt; PLA.predict_type(data[i])\u0026lt;\u0026lt;\u0026#34;, actual -\u0026gt; \u0026#34;\u0026lt;\u0026lt;data[i].to_str(); if(PLA.predict_type(data[i])==data[i].get_type()){ std::cout\u0026lt;\u0026lt;GREEN\u0026lt;\u0026lt;\u0026#34; ✓ \\n\u0026#34;\u0026lt;\u0026lt;RESET; n_correct+=1; }else{ std::cout\u0026lt;\u0026lt;RED\u0026lt;\u0026lt;\u0026#34; x \\n\u0026#34;\u0026lt;\u0026lt;RESET; } } std::cout\u0026lt;\u0026lt;PLA.to_str()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; std::cout\u0026lt;\u0026lt;\u0026#34;correct rate: \u0026#34;\u0026lt;\u0026lt;(n_correct/n_data)*100\u0026lt;\u0026lt;\u0026#34;%, time: \u0026#34;\u0026lt;\u0026lt;((double)end-start)/CLK_TCK; return 0; } ","date":"2022-05-12T14:20:28Z","image":"https://i.imgur.com/M3cjS9J.png","permalink":"https://blog.yuto0226.com/post/perceptron/","title":"[C++]感知機 PLA"},{"content":"BIT A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. -wiki\n樹狀數組也稱作 Fenwick Tree 或 Binary Indexed Tree(BIT)，用來儲存資料，且可以快速求出前綴和或區間加總。對於一個長度 n 的陣列，可以在 O(n) 的時間初始化，在 O(n) 時間詢問一個前綴的訊息例如前綴和，以及在 O(n) 的時間修改其中一個值。但是 BIT 的缺點就是有些問題無法轉為前綴間的運算，無法個別操作元素。\n由上面這張圖可了解 BIT 儲存的區間。Index[] 為儲存資料的陣列，BIT[] 為實際上儲存的區間。\n通常一個數狀數組會有 3 個函式:\nuptade(idx,delta): 將 delta 加到 idx 的節點上 query(index): 查詢從第一個位置到 idx 的所有節點的加總 range_query(idx_this,idx_that): 查詢從 idx_this 到 idx_that 間所有節點的總和 lowbit() lowbit 是為了求一個二進位數中最低位1的值(最靠近右邊的 1 的值)，構成 BIT 的核心\n1 int lowbit(int x) {return x\u0026amp;(-x);} 在程式碼中 -x 會是 x 的補數加 1 ，把 x 和 -x 做 and 運算，得到的數即是 x 的 lowbit。以 lowbit(4) 為例，4 的二進位置表示是 4(2)=0100，其補數為 ~4(2)=1011，我們便可以求出 -x=1011+1=1100，再把 0100 和 1100 進行 and 運算即可求出其 lowbit(4)=0100。\nUpdate Tree 在 Update Tree 中可以看出如何將值加到節點上。當更新一個節點時，會沿著節點間的邊(edge)向上把每個父節點(parent)都加上同樣的值。例如在一號節點上加上 5，那麼節點 2、4、8 也都會加上 5。\n節點 i 的父節點是 i-lowbit(i) Query Tree 在 Query Tree 中可以看出怎麼求出該索引的前綴。查詢某索引的前綴時，回傳的值會是該索引對應節點的值沿著邊把所有祖先(ancestor)的值相加。例如要求索引 7 的前綴，回傳的值會是節點 4、6、7 的相加。\n節點 i 的父節點是 i+lowbit(i) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; #define bit_capacity 100001 class bit{ public: int length; // 更新元素值 void update(int i,int delta); // 前綴和 int query(int i); // 區間查詢 int query(int f,int l); // 實際儲存的陣列 int *bitree=index; private: int lowbit(int x) {return x\u0026amp;(-x);} int index[bit_capacity]; }; void bit::update(int i,int delta){ while(i\u0026lt;=length){ index[i]+=delta; i+=lowbit(i); } } int bit::query(int i){ int sum =0; while(i\u0026gt;0){ sum+=index[i]; i-=lowbit(i); } return sum; } int bit::query(int f,int l){ return query(l)-query(f); } int main(){ bit tree; tree.length=10; for(int i=1;i\u0026lt;=10;i++) tree.update(i,i); for(int i=1;i\u0026lt;=10;i++){ std::cout\u0026lt;\u0026lt;\u0026#34;BIT[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;tree.bitree[i]\u0026lt;\u0026lt;std::endl; } return 0; } ","date":"2022-04-01T11:52:00Z","image":"https://i.imgur.com/ISJQZSj.png","permalink":"https://blog.yuto0226.com/post/bitree/","title":"[C++]BIT 樹狀樹組"},{"content":"題目 2019TOI1214 新手同好會 5. 卷積神經網路 (CNN) {試題連結}\n問題敘述 卷積神經網絡 (Convolutional Neural Network) 簡稱 CNN，是現在最火紅的深度學習課程必教的模型。 CNN 在影像識別方面非常厲害，許多影像辨識的模型都是以 CNN 的架構為基礎去做延伸。 CNN 分為三個部分：卷積層 (convolution layer)、池化層 (pooling layer) 和全連接層 (fully connected layer)。 卷積層用於提取影像特徵，池化層減小資料的空間大小，全連接層主要目的為實現分類。 池化層最常見的作法是最大池化法 (max pooling)，它將輸入的影像劃分為若干個 2×2 的矩形子區域，對每個子區域輸出最大值。 給定一個 n×n 的二維陣列，請實作最大池化演算法並輸出池化後的結果。\n最大池化法示意圖 圖片來源：https://embarc.org/embarc_mli/doc/build/html/MLI_kernels/pooling_max.html\n輸入格式 第一行有一個正整數n（4 \u0026lt;= n \u0026lt;= 20，n為2的倍數），代表輸入影像邊長。接下去有n行，每行各有n個數字，數值範圍在正負 2^31 之間，以空白隔開，代表影像陣列中的資料值。\n輸出格式 輸出經2x2 最大池化後的結果。\n範例測資 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 輸入1 : 4 12 20 30 0 8 12 2 0 34 70 37 4 112 100 25 12 輸出1 : 20 30 112 37 輸入2 : 6 10 2 0 12 1 3 21 0 13 2 2 0 0 0 0 10 0 0 19 2 0 13 61 1 0 1 32 3 0 2 9 2 0 31 11 0 輸出2 : 21 13 3 19 13 61 9 38 11 解題方向 簡化題目後，我們可以得出題目是要我們把一個大矩陣都拆成2*2的小矩陣。然後把每個小矩陣的最大值輸出成一個新的矩陣，而這個過程被稱作池化。了解題目的要求後就簡單了，我的作法是以一個小區塊先池化，輸出後再處理下一個小區塊。\n如下圖所示，而實際的方法可以把輸入的影像邊常除2，再丟進迴圈裡跑。這樣迴圈每跑次就是處理一組小矩陣。 比較要注意的是後續處理比較四格大小的時候，要記得把迴圈索引值乘2。\n參考程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n; cin\u0026gt;\u0026gt;n; int pool[n][n]; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;n;j++){ cin\u0026gt;\u0026gt;pool[i][j]; } } int max; for(int i=0;i\u0026lt;n/2;i++){ for(int j=0;j\u0026lt;n/2;j++){ max=pool[2*i][2*j]; max=(pool[2*i+1][2*j]\u0026gt;max)?pool[2*i+1][2*j]:max; max=(pool[2*i][2*j+1]\u0026gt;max)?pool[2*i][2*j+1]:max; max=(pool[2*i+1][2*j+1]\u0026gt;max)?pool[2*i+1][2*j+1]:max; cout\u0026lt;\u0026lt;max\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"2022-03-18T18:48:23Z","permalink":"https://blog.yuto0226.com/post/zj_e798/","title":"e798. 卷積神經網路"},{"content":"題目 Given a non-negative integer x, compute and return the square root of x.\nSince the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.\nNote: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\nExample 1:\n1 2 Input: x = 4 Output: 2 Example 2:\n1 2 3 Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Constraints:\n0 \u0026lt;= x \u0026lt;= 231 - 1 解題方向 連分數法求根號值，可以參考李永樂老師的影片 可以得知 S=a^2+b 中的 a 會等於題目所求的答案\n參考程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int mySqrt(int x) { long count=0; int temp; while(true){ if(count*count\u0026gt;x){ return temp; } temp=count; count++; } return {}; } }; ","date":"2022-03-04T19:50:42Z","permalink":"https://blog.yuto0226.com/post/lc_69/","title":"[LeetCode] 69. Sqrt(x)(C++)"},{"content":"題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\n1 2 3 Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\n1 2 Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3:\n1 2 Input: nums = [3,3], target = 6 Output: [0,1] Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 Only one valid answer exists. 解題方向 用兩個 for 迴圈一個一個去檢查\n參考程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for(int i=0;i\u0026lt;nums.size();i++){ for(int j=i+1;j\u0026lt;nums.size();j++){ if(nums[i]+nums[j]==target){ return vector\u0026lt;int\u0026gt; {i,j}; } } } return {}; } }; ","date":"2022-03-04T19:32:42Z","permalink":"https://blog.yuto0226.com/post/lc_1/","title":"[LeetCode] 1. Two-Sum(C++)"},{"content":"簡介 Flood Fill 演算法是從一個區域中提取若干個連通的點與其他相鄰區域區分開(或分別染成不同顏色)的經典演算法(Algorithm)。因為其思路類似洪水從一個區域擴散到所有能到達的區域而得名。\n實作方法 深度優先搜尋(Depth-First Search,DFS) 廣度優先搜尋(Breadth-First Search,BFS) BFS 實作 把最外面的點加入佇列(Queue)裡面，分別按照佇列中的點染色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // title: flood fill algorithm // date: 2/1 // author: 羅崧瑋 #include\u0026lt;bits/stdc++.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; // terminal color font using namespace std; // matrix size #define row 10 #define col 10 // 上,下,左,右 int nx[4]={0,1,0,-1}; int ny[4]={1,0,-1,0}; // pair type typedef struct pair{ int x; int y; }pair_t; void printa(int a[row][col]); // (i,j) 起始位置 void floodfill(int a[row][col],int i,int j,int newc){ // 染色佇列 queue\u0026lt;pair_t\u0026gt; pos; pos.push({i,j}); // 染色 while(!pos.empty()){ auto f=pos.front(); i=f.x; j=f.y; pos.pop(); // 邊界檢查 \u0026amp; 同色檢查 if(a[i][j]\u0026lt;0 || a[i][j]==newc) continue; a[i][j]=newc; printa(a); for(int b=0;b\u0026lt;4;b++) pos.push({i+nx[b],j+ny[b]}); } } void printa(int a[row][col]){ system(\u0026#34;clear\u0026#34;); for(int i=0;i\u0026lt;row;i++){ for(int j=0;j\u0026lt;col;j++){ if(a[i][j]\u0026lt;0) cout\u0026lt;\u0026lt;\u0026#34;\\033[37;7m\u0026#34;\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;\u0026#34;\\033[0m\u0026#34;; else if(a[i][j]==5) cout\u0026lt;\u0026lt;\u0026#34;\\033[34;7m\u0026#34;\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;\u0026#34;\\033[0m\u0026#34;; else cout\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;a[i][j]; } cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; usleep(200000); } int main() { // matrix int a[row][col]={{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}, {-1, 0, 0, 0, 0, 0,-1, 0, 0,-1}, {-1, 0, 0, 0, 0, 0,-1, 0, 0,-1}, {-1, 0, 0,-1, 0, 0, 0,-1,-1,-1}, {-1, 0, 0,-1, 0, 0,-1, 0, 0,-1}, {-1, 0, 0,-1, 0, 0,-1, 0, 0,-1}, {-1, 0,-1,-1, 0,-1, 0, 0, 0,-1}, {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1}, {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1}, {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}}; floodfill(a,1,1,5); cout\u0026lt;\u0026lt;\u0026#34;final :\\n\u0026#34;; printa(a); return 0; } Reference 資訊之芽: Flood Fill Algorithm Inside code: Flood fill algorithm Wiki: Flood Fill hn_tzy: Linux C/C++ 如何輸出彩色字體 ","date":"2022-02-05T14:29:02Z","image":"https://i.imgur.com/gZKSRXT.png","permalink":"https://blog.yuto0226.com/post/floodfill/","title":"[C++]泛洪演算法 Flood Fill Alogrithm"},{"content":"前言 在學寫C++的過程當中，從 Array 到 Vector 一直是很難跨越的障礙， 因為我的物件導向和指標不是學的很完善，導致會有點看不懂程式碼在做什麼， 所以這次我透過邊實作邊學習的方式來盡量彌補我知識上的不足， 順便做個筆記來記錄。\n簡介 Vector 是 C++ 標準程式庫中的一個 class，可視為會自動擴展容量的陣列， 是C++標準程式庫中的眾多容器(container)之一，以循序(Sequential)的方式維護變數集合， 使用前預先 #include \u0026lt;vector\u0026gt; 即可。\n特色 支援隨機存取 集合尾端增刪元素很快 : 常數時間 O(1) 集合中間增刪元素比較費時 : 線性時間 O(n) 以模板(泛型)方式實現，可以儲存任意類型的變數，包括使用者自定義的資料型態。 成員函式 vector 類別是以容器(Container)模式為基準設計的，也就是說，基本上它有 begin()、end()、size()、max_size()、empty() 以及 swap() 這幾個方法。\n存取元素的方法 v[i] : 存取索引值為 i 的元素值 (索引值從零起算，故第一個元素是v[0]。) v.at(i) : 存取索引值為 i 的元素的值 v.front() : 回傳 vector 第一個元素的值 v.back() : 回傳 vector 最尾端元素的值 用 operator [] 可能會 Segmentation Fault。以 at() 存取會做陣列邊界檢查，如果存取越界將會拋出一個例外，這是與 operator [] 的唯一差異。撰寫較嚴肅、安全性較高的程式時使用 at()。\n新增或移除元素的方法 v.push_back() - 新增元素至 vector 的尾端，必要時會進行記憶體配置。 v.pop_back() - 刪除 vector 最尾端的元素。 v.insert() - 插入一個或多個元素至 vector 內的任意位置。 v.erase() - 刪除 vector 中一個或多個元素。 v.clear() - 清空所有元素。 少依賴 push_back() 的自動記憶體配置，不是不要用 push_back()，是不要讓 push_back() 自己判定記憶體需求，能自己要記憶體的就自己要，善用 reserve()、resize() 或建構子(constructor)引數。\n取得長度/容量 v.size() - 取得 vector 目前持有的元素個數。 v.empty() - 如果 vector 內部為空，則傳回 true 值。 v.capacity() - 取得 vector 目前可容納的最大元素個數。這個方法與記憶體的組態有關，它通常只會增加，不會因為元素被刪減而隨之減少。\n重新組態/重設長度 v.reserve() - 擴大 vector 的容量大小(組態更多的記憶體)。 v.resize() - 改變 vector 目前持有的元素個數。\nreserve() 的目的是擴大容量。 做完時，vector 的長度不變，capacity 只會長大不會縮小，資料所在位置可能會移動 (因為會重配空間)。因為 vector 一開始是空的，立刻預留顯然比填了資料後才預留省了拷貝資料的時間。 resize() 的目的是改變 vector 的長度。 做完時，vector 的長度會改變為指定的大小，capacity 則視需要調整，確保不小於 size，資料所在位置可能會移動。如果變小就擦掉尾巴的資料，如果變大就補零。補零如果會超過容量，會做重配空間的動作。 迭代 (Iterator) v.begin() - 回傳一個 Iterator，它指向 vector 第一個元素。 v.end() - 回傳一個 Iterator，它指向 vector 最尾端元素的下一個位置(非最末元素)。 v.rbegin() - 回傳一個反向 Iterator，它指向 vector 最尾端元素的。 v.rend() - 回傳一個 Iterator，它指向 vector 的第一個元素的前一個位置。\n使用 vector 實做 在實際使用 vector 之前，我們必須先了解如何宣告 vector 變數。\n初始化 以下即是宣告一個 int 型的 vector，size() 是 0, capacity() 也是 0。\n1 2 3 4 5 6 7 #include \u0026lt;vector\u0026gt; using std::vector; int main() { vector\u0026lt;int\u0026gt; v; return 0; } 使用萬用標頭檔(\u0026lt;bits/stdc++.h\u0026gt;)就可以不用再 #include \u0026lt;vector\u0026gt;。\n在初始化時可以用用 operator = 就把值丟進去，\n1 vector\u0026lt;int\u0026gt; v={1, 2, 3, 4}; 或是使用建構子，\n1 vector\u0026lt;int\u0026gt; v({1, 2, 3, 4}); 若要從其他容器中把值複製過來可以用 operator =，\n1 2 vector\u0026lt;int\u0026gt; v1={1, 2, 3, 4}; vector\u0026lt;int\u0026gt; v2=v1; 同樣地也可以用建構子，\n1 2 vector\u0026lt;int\u0026gt; v1={1, 2, 3, 4}; vector\u0026lt;int\u0026gt; v2(v1); 還可以從 array 裡複製過來，\n1 2 int n[3]={1, 2, 3, 4}; vector\u0026lt;int\u0026gt; v(n, n+3); 範圍複製也是可以的，vector 的可以這樣寫，\n1 2 vector\u0026lt;int\u0026gt; v1 = {1, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt; v2(v1.begin()+2, v1.end()-1); // {3, 4} array 的可以這樣寫，\n1 2 int n[5] = {1, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt; v(n+2, n+4); // {3, 4} 存取元素的方法 1 2 3 4 5 vector\u0026lt;int\u0026gt; v={1, 2, 3, 4}; cout\u0026lt;\u0026lt;v[1]\u0026lt;\u0026lt;endl; // 2 cout\u0026lt;\u0026lt;v.at(2)\u0026lt;\u0026lt;endl; // 3 cout\u0026lt;\u0026lt;v.front()\u0026lt;\u0026lt;endl; // 1 cout\u0026lt;\u0026lt;v.back()\u0026lt;\u0026lt;endl; // 4 新增或移除元素的方法 1 2 3 4 5 6 vector\u0026lt;int\u0026gt; v={1, 2, 3, 4}; v.push_back(5); // {1, 2, 3, 4, 5} v.pop_back(); // {1, 2, 3, 4} v.insert(2,5); // {1, 2, 5, 3, 4} v.erase(2); // {1, 2, 3, 4} v.clear(); // 此時所有元素被清空，但 capacity 為 5 用 swap() 刪除元素 成員函式 swap()，這個函式用來交換兩個 vector 容器中的元素。 因此可以與一個具有相同資料類型的內容為空的局部變數swap，從而實現徹底刪除元素、釋放容量的目的。\n1 2 3 vector\u0026lt;int\u0026gt; v1={1, 2, 3, 4}; vector\u0026lt;int\u0026gt; v2; v1.swap(v2); // v1 內的元素與 v2 交換，即 v1 內所有元素被刪除 長度/容量以及配置大小 1 2 3 4 5 6 7 8 vector\u0026lt;int\u0026gt; v={1, 2, 3, 4}; v.reserve(10); // 把 capacity 擴大為 10 cout\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; // 4 cout\u0026lt;\u0026lt;v.capacity()\u0026lt;\u0026lt;endl; // 10 cout\u0026lt;\u0026lt;v.empty()\u0026lt;\u0026lt;endl; // 0 v.clear(); cout\u0026lt;\u0026lt;v.empty()\u0026lt;\u0026lt;endl; // 1 v.resize(2); // {1, 2, 3, 4, 0, 0} 尋訪元素 尋訪元素除了像陣列那樣寫以外，還可以用疊代器寫\n1 2 3 4 5 6 7 8 9 10 vector\u0026lt;int\u0026gt; v={1, 2, 3, 4, 5}; for(int i=0; i\u0026lt;v.size(); i++) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; for(int i=0; i\u0026lt;v.size(); i++) cout \u0026lt;\u0026lt; v.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; vector\u0026lt;int\u0026gt;::iterator it; for(it=v.begin(); it!=v.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; vector::assign() vector::assign() 是 C++ 中的 STL，它通過替換舊元素為向量元素分配新值。如果需要，它也可以修改向量的大小。\n分配常量值 1 2 vector\u0026lt;int\u0026gt; v; v.assign(5, 10); // {10, 10, 10, 10 ,10} 從 array 或 vector 分配值 除了上面有提過用 operator = 或建構子的方式在初始化時賦值， 也可以透過 assign() 來執行。\n1 2 3 4 5 6 int a[5]={1, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; v1.assign(a,a+4); // {1, 2, 3, 4} v2.assign(v1.begin(),v1.begin()+2); // {1, 2} 修改 vector 1 2 3 vector\u0026lt;int\u0026gt; v; v.assign(5, 10); // {10, 10, 10, 10 ,10} v.assign(v.begin(), v.begin() + 3); // {10, 10, 10} Reference Mr. Opengate: C/C++ - Vector (STL) 用法與心得完全攻略 ShengYu Talk: C++ std::vector 用法與範例 Wiki 維基百科: Vector (STL) 純淨天空: C++ vector::assign()用法及代碼示例 ","date":"2022-01-05T20:24:37Z","image":"https://i.imgur.com/LV9jk0s.png","permalink":"https://blog.yuto0226.com/post/%E5%90%91%E9%87%8F-vectorstl/","title":"向量 Vector(STL)"},{"content":"簡介 何謂鏈接串列(Linked List)?串列是一種常見的資料結構， 使用節點儲存資料，且透過接點的指標指向下一個節點， 形成一串記憶體位置不相連的資料串。\nLinked List vs Array Array Pros\nrandom access：只要利用index即可在O(1)時間對Array的資料做存取。 較Linked list為節省記憶體空間：因為Linked list需要多一個pointer來記錄下一個節點的記憶體位置。 Cons\n新增/刪除資料很麻煩：若要在第一個位置新增資料，就需要O(N)時間把矩陣中所有元素往後移動。同理，若要刪除第一個位置的資料，也需要O(N)時間把矩陣中剩餘的元素往前移動。 若資料數量時常在改變，要時常調整矩陣的大小，會花費O(N)的時間在搬動資料(把資料從舊的矩陣移動到新的矩陣)。 適用時機\n希望能夠快速存取資料。 已知欲處理的資料數量，便能確認矩陣的大小。 要求記憶體空間的使用越少越好。 Linked List Pros\n新增/刪除資料較Array簡單，只要對O(1)個節點調整pointer即可，不需要如同Array般搬動其餘元素。 Linked list的資料數量可以是動態的，不像Array會有resize的問題。 Cons\n因為Linked list沒有index，若要找到特定節點，需要從頭(Node *first)開始找起，搜尋的時間複雜度為O(N)。 需要額外的記憶體空間來儲存pointer。 適用時機\n無法預期資料數量時，使用Linked list就沒有resize的問題。 需要頻繁地新增/刪除資料時。 不需要快速查詢資料。 用 class 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026lt;bits/stdc++.h\u0026gt; using std::cout; using std::endl; class Linkedlist; class Node{ private: int data; Node *next; public: Node():data(0),next(0){}; Node(int x):data(x),next(0){}; friend class LinkedList; }; class LinkedList{ private: Node *first; public: LinkedList():first(0){}; void printlist(); void push_front(int x); void push_back(int x); void erase(int x); void clear(); void reverse(); }; void LinkedList::printlist(){ if(first==0){ cout\u0026lt;\u0026lt;\u0026#34;List is empty.\\n\u0026#34;; return; } Node *current=first; while(current!=0){ cout\u0026lt;\u0026lt;current-\u0026gt;data\u0026lt;\u0026lt;\u0026#34; \u0026#34;; current=current-\u0026gt;next; } cout\u0026lt;\u0026lt;endl; } void LinkedList::push_front(int x){ Node *newNode=new Node(x); newNode-\u0026gt;next=first; first=newNode; } void LinkedList::push_back(int x){ Node *newNode=new Node(x); if(first==0){ first=newNode; return; } Node *current=first; while(current-\u0026gt;next!=0){ current=current-\u0026gt;next; } current-\u0026gt;next=newNode; } void LinkedList::erase(int x){ Node *current=first; Node *previous=0; while(current!=0\u0026amp;\u0026amp;current-\u0026gt;data!=x){ previous=current; current=current-\u0026gt;next; } if(current==0){ cout\u0026lt;\u0026lt;\u0026#34;There\u0026#39;s no \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; in list.\\n\u0026#34;; return; }else if(current=first){ first=current-\u0026gt;next; delete current; current=0; return; }else{ previous-\u0026gt;next=current-\u0026gt;next; delete current; current=0; return; } } void LinkedList::clear(){ Node *current=first; first=first-\u0026gt;next; delete current; current=0; } void LinkedList::reverse(){ if(first==0||first-\u0026gt;next==0) return; Node *previous=0, *current=first, *preceding=first-\u0026gt;next; while(preceding!=0){ current-\u0026gt;next=previous; previous=current; current=preceding; preceding=preceding-\u0026gt;next; } current-\u0026gt;next=previous; first=current; } int main(){ LinkedList list; list.push_front(1); list.push_front(2); list.printlist(); return 0; } Reference http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html\n","date":"2022-01-01T21:00:11Z","image":"https://i.imgur.com/qkADZ5a.png","permalink":"https://blog.yuto0226.com/post/linkedlist/","title":"[C++]鏈接串列 Linked List"},{"content":"b004: 一個都不能少 題目 進德女子監獄座落於自由女中旁，是間作風開放的監獄，每到中午時間便會放風讓收容人到外面用餐。當然還是會有人逾時不歸，身為管理者的美惠，每天總是要為哪些人沒有回來而傷透腦筋。現在想請你寫一個程式，幫助美惠找出哪些人沒有回來。\n輸入說明： 一開始有兩個正整數 N、M (0\u0026lt;=M\u0026lt;N\u0026lt;=20)，N 代表收容人的人數(編號從 1 到 N)，M 代表回來的人數，接下來有 M 個正整數，分別代表這 M 位已經回來的收容人編號(不用考慮編號超出範圍或其他錯誤)。\n解題方向 我覺得這一題我的解法算笨 我想說直接把犯人編號當陣列的索引用 然後在回來的編號裡面放值 最後再去檢查\n應該還可以再精簡一點 感覺有些程式碼有點多餘 不過我懶得改:P\n範例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; int back[22]={0}; int out[22]={0}; int N,M; int is_out(int); int temp; int main() { cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;M; int outNum=N-M; for(int i=0;i\u0026lt;M;i++){ cin\u0026gt;\u0026gt;temp; back[temp]=temp; temp=0; } for(int i=1;i\u0026lt;=N;i++){ if(back[i]\u0026gt;0){ out[i]=0; continue; }else{ out[i]=i; } } for(int i=0;i\u0026lt;22;i++){ if(out[i]==0){ continue; }else{ cout\u0026lt;\u0026lt;out[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } return 0; } ","date":"2021-09-15T18:13:18Z","permalink":"https://blog.yuto0226.com/post/zj_b004/","title":"b004. 一個都不能少"},{"content":"前言 近期Pop cat風靡全球 大家都想拿到第一名 什麼是Pop cat? 這就要從一隻可愛的貓說起\nPopcat風潮來自推特上一段爆紅的貓咪影片 這隻名為Oatmeal的貓咪正在向主人Xavier撒嬌 嘴巴一開一合的 樣子非常可愛 Xavier也把Oatmeal的圖片做成gif圖 後來被他的朋友PO到Reddit論壇上 突然爆紅 被歐美網友們做成各式各樣的迷因（meme） 搭配上「POP」的音效 -數位時代。檢自https://www.bnext.com.tw/article/64440/popcat-click-competition-janis (2021/08/19)\nSo there\u0026#39;s a video with some images of my cat Oatmeal out and here\u0026#39;s the full clip of him chirping at a bug. pic.twitter.com/4MVTWiIknc\n\u0026mdash; Xavier (@XavierBFB) October 11, 2020 我那時就想 一直點一直點手很酸 國外也有人用連點器 (物理) 那為什麼我不來試看看用程式寫 然後又剛好看到 Youtube 上的 Selenium 教學 剛好可以讓我寫出連點器 於是便著手編寫了\nSelenium Selenium 是一個綜合性的項目，為web瀏覽器的自動化提供了各種工具和依賴包\n要在 Python 中使用 Selenium 要先安裝它的套件\n1 $ pip install selenium 然後要安裝對應的 WebDriver 才能讓它在瀏覽器上面跑 這邊就用 Chrome (網址) 記得要挑對版本下載 下載完後把他丟到程式檔案的同一個資料夾就可以了\n程式碼 Github: 連結\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from selenium import webdriver import time import random PATH = \u0026#34;./chromedriver.exe\u0026#34; driver = webdriver.Chrome(PATH) driver.get(\u0026#34;https://popcat.click/\u0026#34;) neko = driver.find_element_by_id(\u0026#34;app\u0026#34;) # 隨機點擊次數及休息時間 click_random = int(random.random()*500) sec_random = int(random.random()*5) c = 0 while c \u0026lt; 1: for i in range(click_random): neko.click() time.sleep(sec_random) ","date":"2021-08-18T19:13:26Z","permalink":"https://blog.yuto0226.com/post/popcat-%E8%87%AA%E5%8B%95%E9%80%A3%E9%BB%9E%E5%99%A8/","title":"POPCAT 自動連點器"},{"content":"前言 我們都知道在 C++ 裡面 如過要實現加法的話可以寫成\n1 2 3 4 int a=1; int b=2; a+b; 答案理所當然會是 3 雖然我們是用 C++ 去編寫的 但是電腦執行的卻是編譯過的機械碼 繞我不禁好奇，電腦是如何進行加法的 ? 不是透過寫程式碼讓他編譯，而是最原始的方法 單純的電子訊號，也就是 0 和 1\n二進位制 5+5 ，只要有好好學過數學的人都應該會知道答案是 10 這種進位制即是大家最熟悉的 10 進位制 ，也就是當數字加到 10 時要進一位 2 進位制 也是一樣的概念，當數字加到 2 時要進一位 舉例來說 1+1 的答案就會是 10\n2 進位制 廣泛被運用在電腦上面，而一個數字也被稱作位元\n邏輯閘 邏輯閘是在積體電路上的基本組件。這些電晶體的組合可以使代表兩種訊號的高低電平在通過它們之後產生高電平或者低電平的訊號。高、低電平可以分別代表邏輯上的「真」與「假」或二進位當中的1和0，從而實現邏輯運算。常見的邏輯閘包括與閘，或閘，非閘，互斥或閘（也稱：互斥或）等等。(維基百科)\nAND \\ 1 0 1 1 0 0 0 0 OR \\ 1 0 1 1 1 0 1 0 XOR \\ 1 0 1 0 1 0 1 0 實作 這次的實作是參考 Ben Eater 的 Learn how computers add numbers and build a 4 bit adder circuit\n影片透過觀察 2進位制 加法 的規律，歸納出了以下電路圖\n知道要怎麼接之後就簡單了 剩下的就只是把它實做出來而已 成品長這樣\n01001 + 01100 的結果為 10101 和實際操作的結果一樣\n","date":"2021-06-16T17:26:48Z","permalink":"https://blog.yuto0226.com/post/%E4%BA%8C%E9%80%B2%E4%BD%8D%E5%88%B6-%E9%82%8F%E8%BC%AF%E9%96%98%E5%AF%A6%E4%BD%9C/","title":"二進位制 \u0026 邏輯閘實作"}]